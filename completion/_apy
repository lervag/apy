#compdef apy

__model() {
  _arguments $opts_help '*:: :->subcmds' && return 0

  local -a subcmds_model
  subcmds_model=( \
    'edit-css:Edit CSS template for specified model' \
    'rename:Rename model' \
    )

  if (( CURRENT == 1 )); then
    _describe -t commands 'apy commands / project' subcmds_model
    return
  fi

  case "$words[1]" in
    edit-css)
      opts=( \
        '(-m --model)'{-m,--model}'[Specify model]:model:_apy_models' \
        '(-s --sync-after)'{-s,--sync-after}'[Synchronize after edit]' \
        $opts_help \
        );;
    rename)
      opts=( \
        '::old-name' \
        '::new-name' \
        $opts_help \
        );;
  esac

  _arguments $opts
}

_apy() {
  zstyle ":completion:*:*:apy:*" sort false

  local -a opts opts_help subcmds

  opts_help=( '(-h --help)'{-h,--help}'[Show help]' )

  opts=( \
    $opts_help
    '(-b --base)'{-b,--base}'[Set base directory]:Anki base directory:_files -/' \
    )

  subcmds=( \
    'add:Add notes interactively from terminal' \
    'add-from-file:Add notes from Markdown file (alias for update-from-file)' \
    'add-single:Add a single note from command line arguments' \
    'backup:Backup Anki database to specified target file' \
    'check-media:Check media' \
    'edit:Edit notes that match QUERY directly' \
    'info:Print some basic statistics' \
    'list-cards:List cards that match QUERY' \
    'list-cards-table:List cards that match QUERY in table format' \
    'list-models:List available models' \
    'list-notes:List notes that match QUERY' \
    'model:Interact with the models' \
    'reposition:Reposition new cards that match QUERY' \
    'review:Review/Edit notes that match QUERY [default: marked/flagged]' \
    'sync:Synchronize collection with AnkiWeb' \
    'tag:Add or remove tags from notes that match QUERY' \
    'update-from-file:Update existing or add new notes from Markdown file' \
    )

  _arguments $opts '*:: :->subcmds' && return 0

  if (( CURRENT == 1 )); then
    _describe -t commands 'apy commands' subcmds
    return
  fi

  case "$words[1]" in
    add)
      opts=( \
        '(-t --tags)'{-t,--tags}'[Specify tags]:tags:_apy_tags' \
        '(-m --model)'{-m,--model}'[Specify model]:model:_apy_models' \
        '(-d --deck)'{-d,--deck}'[Specify deck]:deck:' \
        $opts_help \
        );;
    add-single)
      opts=( \
        '(-s --preset)'{-s,--preset}'[Specify a preset]:preset:' \
        '(-t --tags)'{-t,--tags}'[Specify tags]:tags:_apy_tags' \
        '(-m --model)'{-m,--model}'[Specify model]:model:_apy_models' \
        '(-d --deck)'{-d,--deck}'[Specify deck]:deck:' \
        '::Fields' \
        $opts_help \
        );;
    add-from-file|update-from-file)
      opts=( \
        '::Markdown input file:_files -g "*.md"' \
        '(-t --tags)'{-t,--tags}'[Specify tags]:tags:_apy_tags' \
        '(-d --deck)'{-d,--deck}'[Specify deck]:deck:' \
        '(-u --update-file)'{-u,--update-file}'[Update original file with note IDs]' \
        $opts_help \
        );;
    backup)
      opts=( \
        '::Target file' \
        '(-m --include-media)'{-m,--include-media}'[Include media files]:media:' \
        '(-l --legacy)'{-l,--legacy}'[Support older Anki Versions]:legacy:' \
        $opts_help \
        );;
    edit)
      opts=( \
        '::Query' \
        '(-f --force-multiple)'{-f,--force-multiple}'[Allow editing multiple notes]' \
        $opts_help \
        );;
    info)
      opts=( $opts_help );;
    list-cards)
      opts=( \
        '::Query' \
        '(-v --verbose)'{-v,--verbose}'[Print note details]' \
        $opts_help \
        );;
    list-cards-table)
      opts=( \
        '::Query' \
        '(-w --wrap)'{-w,--wrap}'[Wrap the question and answer on multiple lines]' \
        '(-a --show-answer)'{-a,--show-answer}'[Display answer]' \
        '(-m --show-model)'{-m,--show-model}'[Display model]' \
        '(-c --show-cid)'{-c,--show-cid}'[Display card ids]' \
        '(-d --show-due)'{-d,--show-due}'[Display card due time in days]' \
        '(-t --show-type)'{-t,--show-type}'[Display card type]' \
        '(-e --show-ease)'{-e,--show-ease}'[Display card ease]' \
        '(-l --show-lapses)'{-l,--show-lapses}'[Display card number of lapses]' \
        $opts_help \
        );;
    list-models)
      opts=( \
        $opts_help \
        );;
    list-notes)
      opts=( \
        '::Query' \
        '(-c --show-cards)'{-c,--show-cards}'[Print card specs]' \
        '(-r --show-raw-fields)'{-r,--show-raw-fields}'[Print raw field data]' \
        '(-v --verbose)'{-v,--verbose}'[Print note details]' \
        $opts_help \
        );;
    model) __model; return;;
    review)
      opts=( \
        '::Query' \
        '(-m --check-markdown-consistency)'{-m,----check-markdown-consistency}'[Check for Markdown consistency]' \
        '(-n --cmc-range)'{-n,--cmc-range}'[Number of days to check]:range:' \
        $opts_help \
        );;
    reposition)
      opts=( \
        '::New position for CID' \
        '::Query' \
        $opts_help \
        );;
    tag)
      opts=( \
        '(-a --add-tags)'{-a,--add-tags}'[Add specified tags]:tags:' \
        '(-r --remove-tags)'{-r,--remove-tags}'[Remove specified tags]:tags:_apy_tags' \
        $opts_help \
        '::Query' \
        );;
    *)
      opts=( $opts_help );;
  esac

  _arguments $opts
}

_apy_models() {
  local cache_dir="${XDG_CACHE_HOME:-/tmp/cache}/apy"
  local cache_file="$cache_dir/apy_models"

  local -a models

  [[ -d $cache_dir ]] || mkdir -p $cache_dir
  if [[ -f $cache_file && $(($(date +%s) - $(date -r $cache_file +%s))) -lt 300 ]]
  then
    models=(${(f)"$(<$cache_file)"})
  else
    models=(${(f)"$(apy list-models 2>/dev/null)"})
    print -l $models > $cache_file
  fi
  models=(${models//:/\\:})
  _describe 'model' models
}

_apy_tags() {
  local cache_dir="${XDG_CACHE_HOME:-/tmp/cache}/apy"
  local cache_file="$cache_dir/apy_tags"

  local -a tags

  [[ -d $cache_dir ]] || mkdir -p $cache_dir
  if [[ -f $cache_file && $(($(date +%s) - $(date -r $cache_file +%s))) -lt 300 ]]
  then
    tags=(${(f)"$(<$cache_file)"})
  else
    tags=(${(f)"$(apy tag -s 2>/dev/null)"})
    print -l $tags > $cache_file
  fi

  local current_input="${words[CURRENT]}"
  local current_tag="${current_input##*,}"
  local prefix="${current_input%,*}"

  local -a used_tags_array=(${(s:,:)prefix})
  local -a available_tags
  for tag in $tags; do
    if [[ ! " ${used_tags_array[@]} " =~ " ${tag} " ]]; then
      available_tags+=($tag)
    fi
  done

  if [[ $current_input == *","* ]]; then
    compadd -P "${prefix}," -a available_tags
  else
    _describe 'tags' available_tags
  fi
}

_apy "$@"
